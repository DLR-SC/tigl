// Copyright (c) 2020 RISC Software GmbH
//
// This file was generated by CPACSGen from CPACS XML Schema (c) German Aerospace Center (DLR/SC).
// Do not edit, all changes are lost when files are re-generated.
//
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <cassert>
#include "CPACSCuboid.h"
#include "CPACSElementGeometry.h"
#include "CPACSElementGeometryAddtionalPart.h"
#include "CTiglError.h"
#include "CTiglLogging.h"
#include "CTiglUIDObject.h"
#include "TixiHelper.h"

namespace tigl
{
namespace generated
{
    CPACSCuboid::CPACSCuboid(CPACSElementGeometry* parent)
        : m_lengthX(0)
        , m_depthY(0)
        , m_heightZ(0)
    {
        //assert(parent != NULL);
        m_parent = parent;
        m_parentType = &typeid(CPACSElementGeometry);
    }

    CPACSCuboid::CPACSCuboid(CPACSElementGeometryAddtionalPart* parent)
        : m_lengthX(0)
        , m_depthY(0)
        , m_heightZ(0)
    {
        //assert(parent != NULL);
        m_parent = parent;
        m_parentType = &typeid(CPACSElementGeometryAddtionalPart);
    }

    CPACSCuboid::~CPACSCuboid()
    {
    }

    const CTiglUIDObject* CPACSCuboid::GetNextUIDParent() const
    {
        if (m_parent) {
            if (IsParent<CPACSElementGeometry>()) {
                return GetParent<CPACSElementGeometry>()->GetNextUIDParent();
            }
            if (IsParent<CPACSElementGeometryAddtionalPart>()) {
                return GetParent<CPACSElementGeometryAddtionalPart>()->GetNextUIDParent();
            }
        }
        return nullptr;
    }

    CTiglUIDObject* CPACSCuboid::GetNextUIDParent()
    {
        if (m_parent) {
            if (IsParent<CPACSElementGeometry>()) {
                return GetParent<CPACSElementGeometry>()->GetNextUIDParent();
            }
            if (IsParent<CPACSElementGeometryAddtionalPart>()) {
                return GetParent<CPACSElementGeometryAddtionalPart>()->GetNextUIDParent();
            }
        }
        return nullptr;
    }

    void CPACSCuboid::ReadCPACS(const TixiDocumentHandle& tixiHandle, const std::string& xpath)
    {
        // read element lengthX
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/lengthX")) {
            m_lengthX = tixi::TixiGetElement<double>(tixiHandle, xpath + "/lengthX");
        }
        else {
            LOG(ERROR) << "Required element lengthX is missing at xpath " << xpath;
        }

        // read element depthY
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/depthY")) {
            m_depthY = tixi::TixiGetElement<double>(tixiHandle, xpath + "/depthY");
        }
        else {
            LOG(ERROR) << "Required element depthY is missing at xpath " << xpath;
        }

        // read element heightZ
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/heightZ")) {
            m_heightZ = tixi::TixiGetElement<double>(tixiHandle, xpath + "/heightZ");
        }
        else {
            LOG(ERROR) << "Required element heightZ is missing at xpath " << xpath;
        }

        // read element alpha
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/alpha")) {
            m_alpha_choice1 = tixi::TixiGetElement<double>(tixiHandle, xpath + "/alpha");
        }

        // read element beta
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/beta")) {
            m_beta_choice1 = tixi::TixiGetElement<double>(tixiHandle, xpath + "/beta");
        }

        // read element gamma
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/gamma")) {
            m_gamma_choice1 = tixi::TixiGetElement<double>(tixiHandle, xpath + "/gamma");
        }

        // read element upperFaceXmin
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceXmin")) {
            m_upperFaceXmin_choice2 = tixi::TixiGetElement<double>(tixiHandle, xpath + "/upperFaceXmin");
        }

        // read element upperFaceXmax
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceXmax")) {
            m_upperFaceXmax_choice2 = tixi::TixiGetElement<double>(tixiHandle, xpath + "/upperFaceXmax");
        }

        // read element upperFaceYmin
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceYmin")) {
            m_upperFaceYmin_choice2 = tixi::TixiGetElement<double>(tixiHandle, xpath + "/upperFaceYmin");
        }

        // read element upperFaceYmax
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceYmax")) {
            m_upperFaceYmax_choice2 = tixi::TixiGetElement<double>(tixiHandle, xpath + "/upperFaceYmax");
        }

        if (!ValidateChoices()) {
            LOG(ERROR) << "Invalid choice configuration at xpath " << xpath;
        }
    }

    void CPACSCuboid::WriteCPACS(const TixiDocumentHandle& tixiHandle, const std::string& xpath) const
    {
        const std::vector<std::string> childElemOrder = { "lengthX", "depthY", "heightZ", "alpha", "beta", "gamma", "upperFaceXmin", "upperFaceXmax", "upperFaceYmin", "upperFaceYmax" };

        // write element lengthX
        tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/lengthX", childElemOrder);
        tixi::TixiSaveElement(tixiHandle, xpath + "/lengthX", m_lengthX);

        // write element depthY
        tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/depthY", childElemOrder);
        tixi::TixiSaveElement(tixiHandle, xpath + "/depthY", m_depthY);

        // write element heightZ
        tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/heightZ", childElemOrder);
        tixi::TixiSaveElement(tixiHandle, xpath + "/heightZ", m_heightZ);

        // write element alpha
        if (m_alpha_choice1) {
            tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/alpha", childElemOrder);
            tixi::TixiSaveElement(tixiHandle, xpath + "/alpha", *m_alpha_choice1);
        }
        else {
            if (tixi::TixiCheckElement(tixiHandle, xpath + "/alpha")) {
                tixi::TixiRemoveElement(tixiHandle, xpath + "/alpha");
            }
        }

        // write element beta
        if (m_beta_choice1) {
            tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/beta", childElemOrder);
            tixi::TixiSaveElement(tixiHandle, xpath + "/beta", *m_beta_choice1);
        }
        else {
            if (tixi::TixiCheckElement(tixiHandle, xpath + "/beta")) {
                tixi::TixiRemoveElement(tixiHandle, xpath + "/beta");
            }
        }

        // write element gamma
        if (m_gamma_choice1) {
            tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/gamma", childElemOrder);
            tixi::TixiSaveElement(tixiHandle, xpath + "/gamma", *m_gamma_choice1);
        }
        else {
            if (tixi::TixiCheckElement(tixiHandle, xpath + "/gamma")) {
                tixi::TixiRemoveElement(tixiHandle, xpath + "/gamma");
            }
        }

        // write element upperFaceXmin
        if (m_upperFaceXmin_choice2) {
            tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/upperFaceXmin", childElemOrder);
            tixi::TixiSaveElement(tixiHandle, xpath + "/upperFaceXmin", *m_upperFaceXmin_choice2);
        }
        else {
            if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceXmin")) {
                tixi::TixiRemoveElement(tixiHandle, xpath + "/upperFaceXmin");
            }
        }

        // write element upperFaceXmax
        if (m_upperFaceXmax_choice2) {
            tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/upperFaceXmax", childElemOrder);
            tixi::TixiSaveElement(tixiHandle, xpath + "/upperFaceXmax", *m_upperFaceXmax_choice2);
        }
        else {
            if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceXmax")) {
                tixi::TixiRemoveElement(tixiHandle, xpath + "/upperFaceXmax");
            }
        }

        // write element upperFaceYmin
        if (m_upperFaceYmin_choice2) {
            tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/upperFaceYmin", childElemOrder);
            tixi::TixiSaveElement(tixiHandle, xpath + "/upperFaceYmin", *m_upperFaceYmin_choice2);
        }
        else {
            if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceYmin")) {
                tixi::TixiRemoveElement(tixiHandle, xpath + "/upperFaceYmin");
            }
        }

        // write element upperFaceYmax
        if (m_upperFaceYmax_choice2) {
            tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/upperFaceYmax", childElemOrder);
            tixi::TixiSaveElement(tixiHandle, xpath + "/upperFaceYmax", *m_upperFaceYmax_choice2);
        }
        else {
            if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceYmax")) {
                tixi::TixiRemoveElement(tixiHandle, xpath + "/upperFaceYmax");
            }
        }

    }

    bool CPACSCuboid::ValidateChoices() const
    {
        return
        (
            (
                (
                    // mandatory elements of this choice must be there
                    m_alpha_choice1.is_initialized()
                    &&
                    m_beta_choice1.is_initialized()
                    &&
                    m_gamma_choice1.is_initialized()
                    &&
                    // elements of other choices must not be there
                    !(
                        m_upperFaceXmin_choice2.is_initialized()
                        ||
                        m_upperFaceXmax_choice2.is_initialized()
                        ||
                        m_upperFaceYmin_choice2.is_initialized()
                        ||
                        m_upperFaceYmax_choice2.is_initialized()
                    )
                )
                +
                (
                    // mandatory elements of this choice must be there
                    m_upperFaceXmin_choice2.is_initialized()
                    &&
                    m_upperFaceXmax_choice2.is_initialized()
                    &&
                    m_upperFaceYmin_choice2.is_initialized()
                    &&
                    m_upperFaceYmax_choice2.is_initialized()
                    &&
                    // elements of other choices must not be there
                    !(
                        m_alpha_choice1.is_initialized()
                        ||
                        m_beta_choice1.is_initialized()
                        ||
                        m_gamma_choice1.is_initialized()
                    )
                )
                == 1
            )
        )
        ;
    }

    const double& CPACSCuboid::GetLengthX() const
    {
        return m_lengthX;
    }

    void CPACSCuboid::SetLengthX(const double& value)
    {
        m_lengthX = value;
    }

    const double& CPACSCuboid::GetDepthY() const
    {
        return m_depthY;
    }

    void CPACSCuboid::SetDepthY(const double& value)
    {
        m_depthY = value;
    }

    const double& CPACSCuboid::GetHeightZ() const
    {
        return m_heightZ;
    }

    void CPACSCuboid::SetHeightZ(const double& value)
    {
        m_heightZ = value;
    }

    const boost::optional<double>& CPACSCuboid::GetAlpha_choice1() const
    {
        return m_alpha_choice1;
    }

    void CPACSCuboid::SetAlpha_choice1(const boost::optional<double>& value)
    {
        m_alpha_choice1 = value;
    }

    const boost::optional<double>& CPACSCuboid::GetBeta_choice1() const
    {
        return m_beta_choice1;
    }

    void CPACSCuboid::SetBeta_choice1(const boost::optional<double>& value)
    {
        m_beta_choice1 = value;
    }

    const boost::optional<double>& CPACSCuboid::GetGamma_choice1() const
    {
        return m_gamma_choice1;
    }

    void CPACSCuboid::SetGamma_choice1(const boost::optional<double>& value)
    {
        m_gamma_choice1 = value;
    }

    const boost::optional<double>& CPACSCuboid::GetUpperFaceXmin_choice2() const
    {
        return m_upperFaceXmin_choice2;
    }

    void CPACSCuboid::SetUpperFaceXmin_choice2(const boost::optional<double>& value)
    {
        m_upperFaceXmin_choice2 = value;
    }

    const boost::optional<double>& CPACSCuboid::GetUpperFaceXmax_choice2() const
    {
        return m_upperFaceXmax_choice2;
    }

    void CPACSCuboid::SetUpperFaceXmax_choice2(const boost::optional<double>& value)
    {
        m_upperFaceXmax_choice2 = value;
    }

    const boost::optional<double>& CPACSCuboid::GetUpperFaceYmin_choice2() const
    {
        return m_upperFaceYmin_choice2;
    }

    void CPACSCuboid::SetUpperFaceYmin_choice2(const boost::optional<double>& value)
    {
        m_upperFaceYmin_choice2 = value;
    }

    const boost::optional<double>& CPACSCuboid::GetUpperFaceYmax_choice2() const
    {
        return m_upperFaceYmax_choice2;
    }

    void CPACSCuboid::SetUpperFaceYmax_choice2(const boost::optional<double>& value)
    {
        m_upperFaceYmax_choice2 = value;
    }

} // namespace generated
} // namespace tigl
