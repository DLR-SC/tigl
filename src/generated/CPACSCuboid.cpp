// Copyright (c) 2020 RISC Software GmbH
//
// This file was generated by CPACSGen from CPACS XML Schema (c) German Aerospace Center (DLR/SC).
// Do not edit, all changes are lost when files are re-generated.
//
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <cassert>
#include "CPACSCuboid.h"
#include "CPACSElementGeometry.h"
#include "CPACSElementGeometryAddtionalPart.h"
#include "CTiglError.h"
#include "CTiglLogging.h"
#include "CTiglUIDObject.h"
#include "TixiHelper.h"

namespace tigl
{
namespace generated
{
    CPACSCuboid::CPACSCuboid(CPACSElementGeometry* parent)
        : m_lengthX(0)
        , m_depthY(0)
        , m_heightZ(0)
    {
        //assert(parent != NULL);
        m_parent = parent;
        m_parentType = &typeid(CPACSElementGeometry);
    }

    CPACSCuboid::CPACSCuboid(CPACSElementGeometryAddtionalPart* parent)
        : m_lengthX(0)
        , m_depthY(0)
        , m_heightZ(0)
    {
        //assert(parent != NULL);
        m_parent = parent;
        m_parentType = &typeid(CPACSElementGeometryAddtionalPart);
    }

    CPACSCuboid::~CPACSCuboid()
    {
    }

    const CTiglUIDObject* CPACSCuboid::GetNextUIDParent() const
    {
        if (m_parent) {
            if (IsParent<CPACSElementGeometry>()) {
                return GetParent<CPACSElementGeometry>()->GetNextUIDParent();
            }
            if (IsParent<CPACSElementGeometryAddtionalPart>()) {
                return GetParent<CPACSElementGeometryAddtionalPart>()->GetNextUIDParent();
            }
        }
        return nullptr;
    }

    CTiglUIDObject* CPACSCuboid::GetNextUIDParent()
    {
        if (m_parent) {
            if (IsParent<CPACSElementGeometry>()) {
                return GetParent<CPACSElementGeometry>()->GetNextUIDParent();
            }
            if (IsParent<CPACSElementGeometryAddtionalPart>()) {
                return GetParent<CPACSElementGeometryAddtionalPart>()->GetNextUIDParent();
            }
        }
        return nullptr;
    }

    void CPACSCuboid::ReadCPACS(const TixiDocumentHandle& tixiHandle, const std::string& xpath)
    {
        // read element lengthX
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/lengthX")) {
            m_lengthX = tixi::TixiGetElement<double>(tixiHandle, xpath + "/lengthX");
        }
        else {
            LOG(ERROR) << "Required element lengthX is missing at xpath " << xpath;
        }

        // read element depthY
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/depthY")) {
            m_depthY = tixi::TixiGetElement<double>(tixiHandle, xpath + "/depthY");
        }
        else {
            LOG(ERROR) << "Required element depthY is missing at xpath " << xpath;
        }

        // read element heightZ
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/heightZ")) {
            m_heightZ = tixi::TixiGetElement<double>(tixiHandle, xpath + "/heightZ");
        }
        else {
            LOG(ERROR) << "Required element heightZ is missing at xpath " << xpath;
        }

        // read element upperFaceXmin
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceXmin")) {
            m_upperFaceXmin = tixi::TixiGetElement<double>(tixiHandle, xpath + "/upperFaceXmin");
        }

        // read element upperFaceXmax
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceXmax")) {
            m_upperFaceXmax = tixi::TixiGetElement<double>(tixiHandle, xpath + "/upperFaceXmax");
        }

        // read element upperFaceYmin
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceYmin")) {
            m_upperFaceYmin = tixi::TixiGetElement<double>(tixiHandle, xpath + "/upperFaceYmin");
        }

        // read element upperFaceYmax
        if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceYmax")) {
            m_upperFaceYmax = tixi::TixiGetElement<double>(tixiHandle, xpath + "/upperFaceYmax");
        }

    }

    void CPACSCuboid::WriteCPACS(const TixiDocumentHandle& tixiHandle, const std::string& xpath) const
    {
        const std::vector<std::string> childElemOrder = { "lengthX", "depthY", "heightZ", "upperFaceXmin", "upperFaceXmax", "upperFaceYmin", "upperFaceYmax" };

        // write element lengthX
        tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/lengthX", childElemOrder);
        tixi::TixiSaveElement(tixiHandle, xpath + "/lengthX", m_lengthX);

        // write element depthY
        tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/depthY", childElemOrder);
        tixi::TixiSaveElement(tixiHandle, xpath + "/depthY", m_depthY);

        // write element heightZ
        tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/heightZ", childElemOrder);
        tixi::TixiSaveElement(tixiHandle, xpath + "/heightZ", m_heightZ);

        // write element upperFaceXmin
        if (m_upperFaceXmin) {
            tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/upperFaceXmin", childElemOrder);
            tixi::TixiSaveElement(tixiHandle, xpath + "/upperFaceXmin", *m_upperFaceXmin);
        }
        else {
            if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceXmin")) {
                tixi::TixiRemoveElement(tixiHandle, xpath + "/upperFaceXmin");
            }
        }

        // write element upperFaceXmax
        if (m_upperFaceXmax) {
            tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/upperFaceXmax", childElemOrder);
            tixi::TixiSaveElement(tixiHandle, xpath + "/upperFaceXmax", *m_upperFaceXmax);
        }
        else {
            if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceXmax")) {
                tixi::TixiRemoveElement(tixiHandle, xpath + "/upperFaceXmax");
            }
        }

        // write element upperFaceYmin
        if (m_upperFaceYmin) {
            tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/upperFaceYmin", childElemOrder);
            tixi::TixiSaveElement(tixiHandle, xpath + "/upperFaceYmin", *m_upperFaceYmin);
        }
        else {
            if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceYmin")) {
                tixi::TixiRemoveElement(tixiHandle, xpath + "/upperFaceYmin");
            }
        }

        // write element upperFaceYmax
        if (m_upperFaceYmax) {
            tixi::TixiCreateSequenceElementIfNotExists(tixiHandle, xpath + "/upperFaceYmax", childElemOrder);
            tixi::TixiSaveElement(tixiHandle, xpath + "/upperFaceYmax", *m_upperFaceYmax);
        }
        else {
            if (tixi::TixiCheckElement(tixiHandle, xpath + "/upperFaceYmax")) {
                tixi::TixiRemoveElement(tixiHandle, xpath + "/upperFaceYmax");
            }
        }

    }

    const double& CPACSCuboid::GetLengthX() const
    {
        return m_lengthX;
    }

    void CPACSCuboid::SetLengthX(const double& value)
    {
        m_lengthX = value;
    }

    const double& CPACSCuboid::GetDepthY() const
    {
        return m_depthY;
    }

    void CPACSCuboid::SetDepthY(const double& value)
    {
        m_depthY = value;
    }

    const double& CPACSCuboid::GetHeightZ() const
    {
        return m_heightZ;
    }

    void CPACSCuboid::SetHeightZ(const double& value)
    {
        m_heightZ = value;
    }

    const boost::optional<double>& CPACSCuboid::GetUpperFaceXmin() const
    {
        return m_upperFaceXmin;
    }

    void CPACSCuboid::SetUpperFaceXmin(const boost::optional<double>& value)
    {
        m_upperFaceXmin = value;
    }

    const boost::optional<double>& CPACSCuboid::GetUpperFaceXmax() const
    {
        return m_upperFaceXmax;
    }

    void CPACSCuboid::SetUpperFaceXmax(const boost::optional<double>& value)
    {
        m_upperFaceXmax = value;
    }

    const boost::optional<double>& CPACSCuboid::GetUpperFaceYmin() const
    {
        return m_upperFaceYmin;
    }

    void CPACSCuboid::SetUpperFaceYmin(const boost::optional<double>& value)
    {
        m_upperFaceYmin = value;
    }

    const boost::optional<double>& CPACSCuboid::GetUpperFaceYmax() const
    {
        return m_upperFaceYmax;
    }

    void CPACSCuboid::SetUpperFaceYmax(const boost::optional<double>& value)
    {
        m_upperFaceYmax = value;
    }

} // namespace generated
} // namespace tigl
