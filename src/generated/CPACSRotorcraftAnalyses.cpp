// Copyright (c) 2016 RISC Software GmbH
//
// This file was generated by CPACSGen from CPACS XML Schema (c) German Aerospace Center (DLR/SC).
// Do not edit, all changes are lost when files are re-generated.
//
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "TixiHelper.h"
#include "CTiglLogging.h"
#include "CTiglError.h"
#include "CPACSRotorcraftAnalyses.h"

namespace tigl
{
    namespace generated
    {
        CPACSRotorcraftAnalyses::CPACSRotorcraftAnalyses(){}
        CPACSRotorcraftAnalyses::~CPACSRotorcraftAnalyses() {}
        
        void CPACSRotorcraftAnalyses::ReadCPACS(const TixiDocumentHandle& tixiHandle, const std::string& xpath)
        {
            // read element aeroPerformance
            if (tixihelper::TixiCheckElement(tixiHandle, xpath + "/aeroPerformance")) {
                m_aeroPerformance = boost::in_place();
                try {
                    m_aeroPerformance->ReadCPACS(tixiHandle, xpath + "/aeroPerformance");
                } catch(const std::exception& e) {
                    LOG(ERROR) << "Failed to read aeroPerformance at xpath << " << xpath << ": " << e.what();
                    m_aeroPerformance = boost::none;
                } catch(const CTiglError& e) {
                    LOG(ERROR) << "Failed to read aeroPerformance at xpath << " << xpath << ": " << e.getError();
                    m_aeroPerformance = boost::none;
                }
            }
            
            // read element paxFlow
            if (tixihelper::TixiCheckElement(tixiHandle, xpath + "/paxFlow")) {
                m_paxFlow = tixihelper::TixiGetElement<std::string>(tixiHandle, xpath + "/paxFlow");
            }
            
            // read element aeroelastics
            if (tixihelper::TixiCheckElement(tixiHandle, xpath + "/aeroelastics")) {
                m_aeroelastics = boost::in_place();
                try {
                    m_aeroelastics->ReadCPACS(tixiHandle, xpath + "/aeroelastics");
                } catch(const std::exception& e) {
                    LOG(ERROR) << "Failed to read aeroelastics at xpath << " << xpath << ": " << e.what();
                    m_aeroelastics = boost::none;
                } catch(const CTiglError& e) {
                    LOG(ERROR) << "Failed to read aeroelastics at xpath << " << xpath << ": " << e.getError();
                    m_aeroelastics = boost::none;
                }
            }
            
            // read element massBreakdown
            if (tixihelper::TixiCheckElement(tixiHandle, xpath + "/massBreakdown")) {
                m_massBreakdown = boost::in_place();
                try {
                    m_massBreakdown->ReadCPACS(tixiHandle, xpath + "/massBreakdown");
                } catch(const std::exception& e) {
                    LOG(ERROR) << "Failed to read massBreakdown at xpath << " << xpath << ": " << e.what();
                    m_massBreakdown = boost::none;
                } catch(const CTiglError& e) {
                    LOG(ERROR) << "Failed to read massBreakdown at xpath << " << xpath << ": " << e.getError();
                    m_massBreakdown = boost::none;
                }
            }
            
            // read element landingGearPositionSafetyMargins
            if (tixihelper::TixiCheckElement(tixiHandle, xpath + "/landingGearPositionSafetyMargins")) {
                m_landingGearPositionSafetyMargins = boost::in_place();
                try {
                    m_landingGearPositionSafetyMargins->ReadCPACS(tixiHandle, xpath + "/landingGearPositionSafetyMargins");
                } catch(const std::exception& e) {
                    LOG(ERROR) << "Failed to read landingGearPositionSafetyMargins at xpath << " << xpath << ": " << e.what();
                    m_landingGearPositionSafetyMargins = boost::none;
                } catch(const CTiglError& e) {
                    LOG(ERROR) << "Failed to read landingGearPositionSafetyMargins at xpath << " << xpath << ": " << e.getError();
                    m_landingGearPositionSafetyMargins = boost::none;
                }
            }
            
            // read element loadAnalysis
            if (tixihelper::TixiCheckElement(tixiHandle, xpath + "/loadAnalysis")) {
                m_loadAnalysis = boost::in_place();
                try {
                    m_loadAnalysis->ReadCPACS(tixiHandle, xpath + "/loadAnalysis");
                } catch(const std::exception& e) {
                    LOG(ERROR) << "Failed to read loadAnalysis at xpath << " << xpath << ": " << e.what();
                    m_loadAnalysis = boost::none;
                } catch(const CTiglError& e) {
                    LOG(ERROR) << "Failed to read loadAnalysis at xpath << " << xpath << ": " << e.getError();
                    m_loadAnalysis = boost::none;
                }
            }
            
            // read element dynamicAircraftModel
            if (tixihelper::TixiCheckElement(tixiHandle, xpath + "/dynamicAircraftModel")) {
                m_dynamicAircraftModel = boost::in_place();
                try {
                    m_dynamicAircraftModel->ReadCPACS(tixiHandle, xpath + "/dynamicAircraftModel");
                } catch(const std::exception& e) {
                    LOG(ERROR) << "Failed to read dynamicAircraftModel at xpath << " << xpath << ": " << e.what();
                    m_dynamicAircraftModel = boost::none;
                } catch(const CTiglError& e) {
                    LOG(ERROR) << "Failed to read dynamicAircraftModel at xpath << " << xpath << ": " << e.getError();
                    m_dynamicAircraftModel = boost::none;
                }
            }
            
            // read element weightAndBalance
            if (tixihelper::TixiCheckElement(tixiHandle, xpath + "/weightAndBalance")) {
                m_weightAndBalance = boost::in_place();
                try {
                    m_weightAndBalance->ReadCPACS(tixiHandle, xpath + "/weightAndBalance");
                } catch(const std::exception& e) {
                    LOG(ERROR) << "Failed to read weightAndBalance at xpath << " << xpath << ": " << e.what();
                    m_weightAndBalance = boost::none;
                } catch(const CTiglError& e) {
                    LOG(ERROR) << "Failed to read weightAndBalance at xpath << " << xpath << ": " << e.getError();
                    m_weightAndBalance = boost::none;
                }
            }
            
            // read element trajectories
            if (tixihelper::TixiCheckElement(tixiHandle, xpath + "/trajectories")) {
                m_trajectories = boost::in_place();
                try {
                    m_trajectories->ReadCPACS(tixiHandle, xpath + "/trajectories");
                } catch(const std::exception& e) {
                    LOG(ERROR) << "Failed to read trajectories at xpath << " << xpath << ": " << e.what();
                    m_trajectories = boost::none;
                } catch(const CTiglError& e) {
                    LOG(ERROR) << "Failed to read trajectories at xpath << " << xpath << ": " << e.getError();
                    m_trajectories = boost::none;
                }
            }
            
            // read element noise
            if (tixihelper::TixiCheckElement(tixiHandle, xpath + "/noise")) {
                m_noise = boost::in_place();
                try {
                    m_noise->ReadCPACS(tixiHandle, xpath + "/noise");
                } catch(const std::exception& e) {
                    LOG(ERROR) << "Failed to read noise at xpath << " << xpath << ": " << e.what();
                    m_noise = boost::none;
                } catch(const CTiglError& e) {
                    LOG(ERROR) << "Failed to read noise at xpath << " << xpath << ": " << e.getError();
                    m_noise = boost::none;
                }
            }
            
            // read element emission
            if (tixihelper::TixiCheckElement(tixiHandle, xpath + "/emission")) {
                m_emission = tixihelper::TixiGetElement<std::string>(tixiHandle, xpath + "/emission");
            }
            
        }
        
        void CPACSRotorcraftAnalyses::WriteCPACS(const TixiDocumentHandle& tixiHandle, const std::string& xpath) const
        {
            // write element aeroPerformance
            if (m_aeroPerformance) {
                tixihelper::TixiCreateElementIfNotExists(tixiHandle, xpath + "/aeroPerformance");
                m_aeroPerformance->WriteCPACS(tixiHandle, xpath + "/aeroPerformance");
            }
            
            // write element paxFlow
            if (m_paxFlow) {
                tixihelper::TixiCreateElementIfNotExists(tixiHandle, xpath + "/paxFlow");
                tixihelper::TixiSaveElement(tixiHandle, xpath + "/paxFlow", *m_paxFlow);
            }
            
            // write element aeroelastics
            if (m_aeroelastics) {
                tixihelper::TixiCreateElementIfNotExists(tixiHandle, xpath + "/aeroelastics");
                m_aeroelastics->WriteCPACS(tixiHandle, xpath + "/aeroelastics");
            }
            
            // write element massBreakdown
            if (m_massBreakdown) {
                tixihelper::TixiCreateElementIfNotExists(tixiHandle, xpath + "/massBreakdown");
                m_massBreakdown->WriteCPACS(tixiHandle, xpath + "/massBreakdown");
            }
            
            // write element landingGearPositionSafetyMargins
            if (m_landingGearPositionSafetyMargins) {
                tixihelper::TixiCreateElementIfNotExists(tixiHandle, xpath + "/landingGearPositionSafetyMargins");
                m_landingGearPositionSafetyMargins->WriteCPACS(tixiHandle, xpath + "/landingGearPositionSafetyMargins");
            }
            
            // write element loadAnalysis
            if (m_loadAnalysis) {
                tixihelper::TixiCreateElementIfNotExists(tixiHandle, xpath + "/loadAnalysis");
                m_loadAnalysis->WriteCPACS(tixiHandle, xpath + "/loadAnalysis");
            }
            
            // write element dynamicAircraftModel
            if (m_dynamicAircraftModel) {
                tixihelper::TixiCreateElementIfNotExists(tixiHandle, xpath + "/dynamicAircraftModel");
                m_dynamicAircraftModel->WriteCPACS(tixiHandle, xpath + "/dynamicAircraftModel");
            }
            
            // write element weightAndBalance
            if (m_weightAndBalance) {
                tixihelper::TixiCreateElementIfNotExists(tixiHandle, xpath + "/weightAndBalance");
                m_weightAndBalance->WriteCPACS(tixiHandle, xpath + "/weightAndBalance");
            }
            
            // write element trajectories
            if (m_trajectories) {
                tixihelper::TixiCreateElementIfNotExists(tixiHandle, xpath + "/trajectories");
                m_trajectories->WriteCPACS(tixiHandle, xpath + "/trajectories");
            }
            
            // write element noise
            if (m_noise) {
                tixihelper::TixiCreateElementIfNotExists(tixiHandle, xpath + "/noise");
                m_noise->WriteCPACS(tixiHandle, xpath + "/noise");
            }
            
            // write element emission
            if (m_emission) {
                tixihelper::TixiCreateElementIfNotExists(tixiHandle, xpath + "/emission");
                tixihelper::TixiSaveElement(tixiHandle, xpath + "/emission", *m_emission);
            }
            
        }
        
        bool CPACSRotorcraftAnalyses::HasAeroPerformance() const
        {
            return static_cast<bool>(m_aeroPerformance);
        }
        
        const CPACSAeroPerformance& CPACSRotorcraftAnalyses::GetAeroPerformance() const
        {
            return *m_aeroPerformance;
        }
        
        CPACSAeroPerformance& CPACSRotorcraftAnalyses::GetAeroPerformance()
        {
            return *m_aeroPerformance;
        }
        
        bool CPACSRotorcraftAnalyses::HasPaxFlow() const
        {
            return static_cast<bool>(m_paxFlow);
        }
        
        const std::string& CPACSRotorcraftAnalyses::GetPaxFlow() const
        {
            return *m_paxFlow;
        }
        
        void CPACSRotorcraftAnalyses::SetPaxFlow(const std::string& value)
        {
            m_paxFlow = value;
        }
        
        bool CPACSRotorcraftAnalyses::HasAeroelastics() const
        {
            return static_cast<bool>(m_aeroelastics);
        }
        
        const CPACSAeroelastics& CPACSRotorcraftAnalyses::GetAeroelastics() const
        {
            return *m_aeroelastics;
        }
        
        CPACSAeroelastics& CPACSRotorcraftAnalyses::GetAeroelastics()
        {
            return *m_aeroelastics;
        }
        
        bool CPACSRotorcraftAnalyses::HasMassBreakdown() const
        {
            return static_cast<bool>(m_massBreakdown);
        }
        
        const CPACSRotorcraftMassBreakdown& CPACSRotorcraftAnalyses::GetMassBreakdown() const
        {
            return *m_massBreakdown;
        }
        
        CPACSRotorcraftMassBreakdown& CPACSRotorcraftAnalyses::GetMassBreakdown()
        {
            return *m_massBreakdown;
        }
        
        bool CPACSRotorcraftAnalyses::HasLandingGearPositionSafetyMargins() const
        {
            return static_cast<bool>(m_landingGearPositionSafetyMargins);
        }
        
        const CPACSLandingGearPositionSafetyMargins& CPACSRotorcraftAnalyses::GetLandingGearPositionSafetyMargins() const
        {
            return *m_landingGearPositionSafetyMargins;
        }
        
        CPACSLandingGearPositionSafetyMargins& CPACSRotorcraftAnalyses::GetLandingGearPositionSafetyMargins()
        {
            return *m_landingGearPositionSafetyMargins;
        }
        
        bool CPACSRotorcraftAnalyses::HasLoadAnalysis() const
        {
            return static_cast<bool>(m_loadAnalysis);
        }
        
        const CPACSLoadAnalysis& CPACSRotorcraftAnalyses::GetLoadAnalysis() const
        {
            return *m_loadAnalysis;
        }
        
        CPACSLoadAnalysis& CPACSRotorcraftAnalyses::GetLoadAnalysis()
        {
            return *m_loadAnalysis;
        }
        
        bool CPACSRotorcraftAnalyses::HasDynamicAircraftModel() const
        {
            return static_cast<bool>(m_dynamicAircraftModel);
        }
        
        const CPACSDynamicAircraftModelAnalysis& CPACSRotorcraftAnalyses::GetDynamicAircraftModel() const
        {
            return *m_dynamicAircraftModel;
        }
        
        CPACSDynamicAircraftModelAnalysis& CPACSRotorcraftAnalyses::GetDynamicAircraftModel()
        {
            return *m_dynamicAircraftModel;
        }
        
        bool CPACSRotorcraftAnalyses::HasWeightAndBalance() const
        {
            return static_cast<bool>(m_weightAndBalance);
        }
        
        const CPACSWeightAndBalance& CPACSRotorcraftAnalyses::GetWeightAndBalance() const
        {
            return *m_weightAndBalance;
        }
        
        CPACSWeightAndBalance& CPACSRotorcraftAnalyses::GetWeightAndBalance()
        {
            return *m_weightAndBalance;
        }
        
        bool CPACSRotorcraftAnalyses::HasTrajectories() const
        {
            return static_cast<bool>(m_trajectories);
        }
        
        const CPACSTrajectories& CPACSRotorcraftAnalyses::GetTrajectories() const
        {
            return *m_trajectories;
        }
        
        CPACSTrajectories& CPACSRotorcraftAnalyses::GetTrajectories()
        {
            return *m_trajectories;
        }
        
        bool CPACSRotorcraftAnalyses::HasNoise() const
        {
            return static_cast<bool>(m_noise);
        }
        
        const CPACSNoiseAnalysis& CPACSRotorcraftAnalyses::GetNoise() const
        {
            return *m_noise;
        }
        
        CPACSNoiseAnalysis& CPACSRotorcraftAnalyses::GetNoise()
        {
            return *m_noise;
        }
        
        bool CPACSRotorcraftAnalyses::HasEmission() const
        {
            return static_cast<bool>(m_emission);
        }
        
        const std::string& CPACSRotorcraftAnalyses::GetEmission() const
        {
            return *m_emission;
        }
        
        void CPACSRotorcraftAnalyses::SetEmission(const std::string& value)
        {
            m_emission = value;
        }
        
    }
}
