#include <vector>
#include <cctype>
#include <fstream>

#include "codegen.h"

auto CapitalizeFirstLetter(std::string str) {
	if (str.empty())
		throw std::runtime_error("String is empty");

	str[0] = std::toupper(str[0]);

	return str;
}

void writeFields(std::ofstream& hpp, const std::vector<Field>& fields) {
	for (const auto& f : fields)
		hpp << "\t\t" << f.fieldType() << " " << f.fieldName() << ";\n";
}

void writeAccessorDeclarations(std::ofstream& hpp, const std::vector<Field>& fields) {
	for (const auto& f : fields) {
		hpp << "\t\tTIGL_EXPORT const " << f.fieldType() << "& Get" << CapitalizeFirstLetter(f.name) << "() const;\n";
		hpp << "\t\tTIGL_EXPORT void Set" << CapitalizeFirstLetter(f.name) << "(const " << f.fieldType() << "& value);\n";
		hpp << "\n";
	}
}

void writeAccessorImplementations(std::ofstream& cpp, const std::string& className, const std::vector<Field>& fields) {
	for (const auto& f : fields) {
		cpp << "\t" << f.fieldType() << " " << className << "::Get" << CapitalizeFirstLetter(f.name) << "() const { return " << f.fieldName() << "; }\n";
		cpp << "\tvoid " << className << "::Set" << CapitalizeFirstLetter(f.name) << "(const " << f.fieldType() << "& value) { " << f.fieldName() << " = value; }\n";
		cpp << "\n";
	}
}

void writeIODeclarations(std::ofstream& hpp, const std::string& className, const std::vector<Field>& fields) {
	hpp << "\t\tTIGL_EXPORT void ReadCPACS(const TixiDocumentHandle& tixiHandle, const std::string& xpath);\n";
	hpp << "\t\tTIGL_EXPORT void WriteCPACS(const TixiDocumentHandle& tixiHandle, const std::string& xpath);\n";
	hpp << "\n";
}

void writeIOImplementations(std::ofstream& cpp, const std::string& className, const std::vector<Field>& fields) {
	// read
	cpp << "\tvoid " << className << "::ReadCPACS(const TixiDocumentHandle& tixiHandle, const std::string& xpath) {\n";
	for (const auto& f : fields) {
		cpp << "\t\t// read " << (f.attribute ? "attribute" : "element") << " " << f.name << "\n";
		if (f.attribute) {
			// we check for the attribute's existence anyway and report errors
			cpp << "\t\tif (TixiCheckAttribute(tixiHandle, xpath, " << f.name << ")) {\n";
			cpp << "\t\t\t" << f.fieldName() << " = TixiGetTextAttribute(tixiHandle, xpath, " << f.name << ");\n";
			if (f.cardinality == Cardinality::One) {
				// attribute must exist
				cpp << "\t\t} else {\n";
				cpp << "\t\t\tLOG(WARNING) << \"Required attribute " << f.name << " is missing\";\n";
				cpp << "\t\t}\n";
			} else
				cpp << "\t\t}\n";
		} else {
			cpp << "\t\tif (TixiCheckElement(tixiHandle, xpath + \"/\" + " << f.name << ")) {\n";
			cpp << "\t\t\t" << f.fieldName() << " = TixiGetTextElement(tixiHandle, xpath + \"/\" + " << f.name << ");\n";
			if (f.cardinality == Cardinality::One || f.cardinality == Cardinality::Many) {
				// element must exist
				cpp << "\t\t} else {\n";
				cpp << "\t\t\tLOG(WARNING) << \"Required element " << f.name << " is missing\";\n";
				cpp << "\t\t}\n";
			} else
				cpp << "\t\t}\n";
		}
		cpp << "\n";
	}
	cpp << "\t}\n";
	cpp << "\n";


	// write
	cpp << "\tvoid " << className << "::WriteCPACS(const TixiDocumentHandle& tixiHandle, const std::string& xpath) {\n";
	for (const auto& f : fields) {
		cpp << "\t\t// write " << (f.attribute ? "attribute" : "element") << " " << f.name << "\n";
		if (f.attribute)
			cpp << "\t\tTixiSaveTextAttribute(tixiHandle, xpath, \"" << f.name << "\", " << f.fieldName() << ");\n";
		else
			cpp << "\t\tTixiSaveTextElement(tixiHandle, xpath, \"" << f.name << "\", " << f.fieldName() << ");\n";
		cpp << "\n";
	}
	cpp << "\t}\n";
	cpp << "\n";
}

void writeLicenseHeader(std::ofstream& f) {
	f << "// This file was autogenerated by CPACSGen, do not edit\n";
	f << "//\n";
	f << "// Licensed under the Apache License, Version 2.0 (the \"License\")\n";
	f << "// you may not use this file except in compliance with the License.\n";
	f << "// You may obtain a copy of the License at\n";
	f << "//\n";
	f << "//     http://www.apache.org/licenses/LICENSE-2.0\n";
	f << "//\n";
	f << "// Unless required by applicable law or agreed to in writing, software\n";
	f << "// distributed under the License is distributed on an \"AS IS\" BASIS,\n";
	f << "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n";
	f << "// See the License for the specific language governing permissions and\n";
	f << "// limitations under the License.\n";
	f << "\n";
}

void generateCode(const std::string& outputLocation, const std::vector<Class>& classes, const std::vector<Enum>& enums) {
	std::system(("mkdir " + outputLocation).c_str()); // TODO

	for (const auto& c : classes) {

		//
		// create header file
		//

		std::ofstream hpp(outputLocation + "/" + c.name + ".h");
		hpp.exceptions(std::ios::failbit | std::ios::badbit);

		hpp << "#pragma once\n";
		hpp << "\n";

		// file header
		writeLicenseHeader(hpp);

		// includes
		hpp << "#include <string>\n";
		hpp << "#include \"tixi.h\"\n";
		hpp << "\n";

		// namespace
		hpp << "namespace tigl {\n";

		// class name and base class
		hpp << "\tclass " << c.name << (c.base.empty() ? "" : " : public " + c.base) << " {\n";
		hpp << "\tpublic:\n";

		// ctor
		hpp << "\t\tTIGL_EXPORT " << c.name << "();\n";
		hpp << "\n";

		// io
		writeIODeclarations(hpp, c.name, c.fields);

		// accessors
		writeAccessorDeclarations(hpp, c.fields);

		hpp << "\tprivate:\n";

		// fields
		writeFields(hpp, c.fields);
		hpp << "\n";

		hpp << "\t};\n";
		hpp << "}\n";
		hpp << "\n";

		//
		// create source file
		//

		std::ofstream cpp(outputLocation + "/" + c.name + ".cpp");
		cpp.exceptions(std::ios::failbit | std::ios::badbit);

		// file header
		writeLicenseHeader(cpp);

		// includes
		cpp << "#include \"IOHelper.h\"\n";
		cpp << "#include \"" << c.name << ".h\"\n";
		cpp << "\n";

		// namespace
		cpp << "namespace tigl {\n";

		// ctor
		cpp << "\t" << c.name << "::" << c.name << "() {}\n";
		cpp << "\n";

		// io
		writeIOImplementations(cpp, c.name, c.fields);

		// accessors
		writeAccessorImplementations(cpp, c.name, c.fields);

		cpp << "}\n";
		cpp << "\n";
	}

	for (const auto& e : enums) {

		//
		// create header file
		//

		std::ofstream hpp(outputLocation + "/" + e.name + ".h");
		hpp.exceptions(std::ios::failbit | std::ios::badbit);

		hpp << "#pragma once\n";
		hpp << "\n";

		// file header
		writeLicenseHeader(hpp);

		// namespace
		hpp << "namespace tigl {\n";

		// enum name
		hpp << "\tenum class " << e.name << " {\n";

		// values
		bool first = true;
		for (const auto& v : e.values) {
			if (first)
				first = false;
			else {
				hpp << ",\n";
			}
			hpp << "\t\t" << v;
		}
		hpp << "\n";

		hpp << "\t};\n";
		hpp << "}\n";
		hpp << "\n";
	}
}